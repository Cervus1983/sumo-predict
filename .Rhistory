day <= 15,
kimarite != "fusen"
) %>% mutate(
below = ordinal1 - ordinal2,
level1 = substr(rank1, 1, 1),
level2 = substr(rank2, 1, 1)
)
)
train <- withOrdinals(
rbind(
sumodbBoutQuery(basho = "2013", division = "m"),
sumodbBoutQuery(basho = "2014", division = "m"),
sumodbBoutQuery(basho = "2015", division = "m")
)) %>% filter(
day <= 15,
kimarite != "fusen"
) %>% mutate(
below = ordinal1 - ordinal2,
level1 = substr(rank1, 1, 1),
level2 = substr(rank2, 1, 1)
)
head(train)
str(train)
train <- withOrdinals(
rbind(
sumodbBoutQuery(basho = "2013", division = "m"),
sumodbBoutQuery(basho = "2014", division = "m"),
sumodbBoutQuery(basho = "2015", division = "m"),
sumodbBoutQuery(basho = "2016", division = "m")
)) %>% filter(
day <= 15,
kimarite != "fusen"
) %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = substr(rank1, 1, 1),
level2 = substr(rank2, 1, 1)
)
str(train)
df <- train
?randomForest
library(randomForest)
install.packages("randomForest")
library(randomForest)
?randomForest
head(df)
head(df[, features])
features <- c("ordinal1", "ordinal2", "below", "level1", "level2")
response <- "win1"
head(df[, features])
head(y = df[, response]9)
head(y = df[, response])
head(df[, response])
nrow(df %>% filter(basho < "2016"))
nrow(df) - nrow(df %>% filter(basho < "2016"))
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = df %>% filter(basho < "2016")
)
df %>% filter(basho < "2016") %>% count(win1)
df <- withOrdinals(
rbind(
sumodbBoutQuery(basho = "2013", division = "m"),
sumodbBoutQuery(basho = "2014", division = "m"),
sumodbBoutQuery(basho = "2015", division = "m"),
sumodbBoutQuery(basho = "2016", division = "m")
)) %>% filter(
day <= 15,
kimarite != "fusen"
) %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = as.factor(substr(rank1, 1, 1)),
level2 = as.factor(substr(rank2, 1, 1))
)
str(df)
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = df %>% filter(basho < "2016"),
importance=TRUE
)
str(model)
plot(model, log = "y")
model
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = df %>% filter(basho < "2016"),
mtry = 3,
importance = TRUE
)
model
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = df %>% filter(basho < "2016"),
importance = TRUE
)
model
past <- rbind(
sumodbBoutQuery(basho = "2016.01", division = "m"),
sumodbBoutQuery(basho = "2016.03", division = "m"),
sumodbBoutQuery(basho = "2016.05", division = "m"),
sumodbBoutQuery(basho = "2016.07", division = "m"),
sumodbBoutQuery(basho = "2016.09", division = "m")
) %>% filter(day <= 15, kimarite != "fusen")
past.summary <- withOrdinals(past) %>%
mutate(below = ordinal1 - ordinal2) %>%
group_by(below) %>%
summarise(total = n(), wins = sum(win1)) %>%
mutate(winRate = wins / total) %>%
arrange(below)
past %>% count(basho)
analyse("simple")
past.summary
test.data <- sumodbBoutQuery(basho = "2016.11", division = "m") %>% filter(kimarite != "fusen")
test.data.withOrdinals <- withOrdinals(test.data)
# different approaches to predicting a bout's outcome
pWin1 <- list(
# baseline: random pick from a beta distribution
random = function(basho, day, shikona1, shikona2) rbeta(1, 1, 1),
# simplistic approach: historical win rate for given difference in rank
#   61.2% with one year's worth of historical data
#   60,2% with three years?!
simple = function(basho, day, shikona1, shikona2) {
df <- test.data.withOrdinals[
test.data.withOrdinals$basho == basho
& test.data.withOrdinals$day == day
& test.data.withOrdinals$shikona1 == shikona1
& test.data.withOrdinals$shikona2 == shikona2
, ]
ifelse(
nrow(df) == 1,
past.summary[which(past.summary$below == df$ordinal1 - df$ordinal2), ]$winRate,
NA
)
}
)
# generates predictions using pWin1[[name]]
approach <- function(name) {
if(name %in% names(pWin1)) {
mapply(
pWin1[[name]],
df$basho,
df$day,
df$shikona1,
df$shikona2,
USE.NAMES = FALSE
)
}
}
# http://mlwiki.org/index.php/ROC_Analysis
analyse <- function(name) {
graphics.off()
pred <- prediction(
predictions = approach(name),
labels = test.data$win1
)
# ROC curve	(AUC in the title)
windows()
plot(
performance(pred, measure = "tpr", x.measure = "fpr"),
colorize = TRUE,
main = sprintf("AUC = %.1f%%", unlist(performance(pred, "auc")@y.values) * 100)
)
lines(x = c(0, 1), y = c(0, 1))
# cutoff plot
windows()
acc = performance(pred, "acc")
ac.val = max(unlist(acc@y.values))
th = unlist(acc@x.values)[unlist(acc@y.values) == ac.val]
plot(
acc,
main = paste("Cutoff:", paste(sprintf("%.1f%%", th[order(th)] * 100), collapse = ", ")),
xlab = ""
)
abline(v = th, col = "grey", lty = 2)
}
analyse("simple")
approach("simple")
name
name <- "simple"
approach <- function(name) {
if(name %in% names(pWin1)) {
mapply(
pWin1[[name]],
test.data$basho,
test.data$day,
test.data$shikona1,
test.data$shikona2,
USE.NAMES = FALSE
)
}
}
# http://mlwiki.org/index.php/ROC_Analysis
analyse <- function(name) {
graphics.off()
pred <- prediction(
predictions = approach(name),
labels = test.data$win1
)
# ROC curve	(AUC in the title)
windows()
plot(
performance(pred, measure = "tpr", x.measure = "fpr"),
colorize = TRUE,
main = sprintf("AUC = %.1f%%", unlist(performance(pred, "auc")@y.values) * 100)
)
lines(x = c(0, 1), y = c(0, 1))
# cutoff plot
windows()
acc = performance(pred, "acc")
ac.val = max(unlist(acc@y.values))
th = unlist(acc@x.values)[unlist(acc@y.values) == ac.val]
plot(
acc,
main = paste("Cutoff:", paste(sprintf("%.1f%%", th[order(th)] * 100), collapse = ", ")),
xlab = ""
)
abline(v = th, col = "grey", lty = 2)
}
analyse("simple")
train.data <- withOrdinals(
rbind(
sumodbBoutQuery(basho = "2016.01", division = "m"),
sumodbBoutQuery(basho = "2016.03", division = "m"),
sumodbBoutQuery(basho = "2016.05", division = "m"),
sumodbBoutQuery(basho = "2016.07", division = "m"),
sumodbBoutQuery(basho = "2016.09", division = "m")
) %>% filter(day <= 15, kimarite != "fusen")
)
train.data.summary <- train.data %>%
mutate(below = ordinal1 - ordinal2) %>%
group_by(below) %>%
summarise(total = n(), wins = sum(win1)) %>%
mutate(winRate = wins / total) %>%
arrange(below)
test.data <- sumodbBoutQuery(basho = "2016.11", division = "m") %>% filter(kimarite != "fusen")
test.data.withOrdinals <- withOrdinals(test.data)
# different approaches to predicting a bout's outcome
pWin1 <- list(
# baseline: random pick from a beta distribution
random = function(basho, day, shikona1, shikona2) rbeta(1, 1, 1),
# simplistic approach: historical win rate for given difference in rank
#   61.2% with one year's worth of historical data
#   60,2% with three years?!
simple = function(basho, day, shikona1, shikona2) {
df <- test.data.withOrdinals[
test.data.withOrdinals$basho == basho
& test.data.withOrdinals$day == day
& test.data.withOrdinals$shikona1 == shikona1
& test.data.withOrdinals$shikona2 == shikona2
, ]
ifelse(
nrow(df) == 1,
train.data.summary[which(train.data.summary$below == df$ordinal1 - df$ordinal2), ]$winRate,
NA
)
}
)
# generates predictions using pWin1[[name]]
approach <- function(name) {
if(name %in% names(pWin1)) {
mapply(
pWin1[[name]],
test.data$basho,
test.data$day,
test.data$shikona1,
test.data$shikona2,
USE.NAMES = FALSE
)
}
}
# http://mlwiki.org/index.php/ROC_Analysis
analyse <- function(name) {
graphics.off()
pred <- prediction(
predictions = approach(name),
labels = test.data$win1
)
# ROC curve	(AUC in the title)
windows()
plot(
performance(pred, measure = "tpr", x.measure = "fpr"),
colorize = TRUE,
main = sprintf("AUC = %.1f%%", unlist(performance(pred, "auc")@y.values) * 100)
)
lines(x = c(0, 1), y = c(0, 1))
# cutoff plot
windows()
acc = performance(pred, "acc")
ac.val = max(unlist(acc@y.values))
th = unlist(acc@x.values)[unlist(acc@y.values) == ac.val]
plot(
acc,
main = paste("Cutoff:", paste(sprintf("%.1f%%", th[order(th)] * 100), collapse = ", ")),
xlab = ""
)
abline(v = th, col = "grey", lty = 2)
}
analyse("simple")
library(randomForest)
df <- train.data %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = as.factor(substr(rank1, 1, 1)),
level2 = as.factor(substr(rank2, 1, 1))
)
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = df %>% filter(basho < "2016"),
importance = TRUE
)
model
library(randomForest)
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = train.data %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = as.factor(substr(rank1, 1, 1)),
level2 = as.factor(substr(rank2, 1, 1))
),
importance = TRUE
)
model
prob = predict(model, test.data, type = "prob")
addFeatures <- function(df) {
df %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = as.factor(substr(rank1, 1, 1)),
level2 = as.factor(substr(rank2, 1, 1))
)
}
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = addFeatures(train.data),
importance = TRUE
)
model
prob = predict(model, addFeatures(test.data), type = "prob")
head(addFeatures(test.data)
)
prepare <- function(df) withOrdinals(df %>% filter(day <= 15, kimarite != "fusen"))
withOrdinals <- function(df) {
map <- unique(df %>% mutate(s = rank2str(rank1)) %>% select(basho, rank = rank1, s)) %>%
arrange(basho, s) %>%
group_by(basho) %>%
mutate(ordinal = row_number()) %>%
select(-s)
merge(
merge(
df %>% mutate(rank = rank1),
map %>% rename(ordinal1 = ordinal)
) %>% select(-rank) %>% mutate(rank = rank2),
map %>% rename(ordinal2 = ordinal)
) %>% select(-rank)
}
# prepares data set
prepare <- function(df) withOrdinals(df %>% filter(day <= 15, kimarite != "fusen"))
# historical data (win rate ~ difference in rank) for "simple" approach
train.data <- prepare(
rbind(
sumodbBoutQuery(basho = "2016.01", division = "m"),
sumodbBoutQuery(basho = "2016.03", division = "m"),
sumodbBoutQuery(basho = "2016.05", division = "m"),
sumodbBoutQuery(basho = "2016.07", division = "m"),
sumodbBoutQuery(basho = "2016.09", division = "m")
)
)
train.data.summary <- train.data %>%
mutate(below = ordinal1 - ordinal2) %>%
group_by(below) %>%
summarise(total = n(), wins = sum(win1)) %>%
mutate(winRate = wins / total) %>%
arrange(below)
test.data <- prepare(sumodbBoutQuery(basho = "2016.11", division = "m"))
head(test.data)
test.data <- prepare(sumodbBoutQuery(basho = "2016.11", division = "m"))
# different approaches to predicting a bout's outcome
pWin1 <- list(
# baseline: random pick from a beta distribution
random = function(basho, day, shikona1, ordinal1, shikona2, ordinal2) rbeta(1, 1, 1),
# simplistic approach: historical win rate for given difference in rank
#   61.2% with one year's worth of historical data
#   60,2% with three years?!
simple = function(basho, day, shikona1, ordinal1, shikona2, ordinal2) train.data.summary[which(train.data.summary$below == ordinal1 - ordinal2), ]$winRate
)
# generates predictions using pWin1[[name]]
approach <- function(name) {
if(name %in% names(pWin1)) {
mapply(
pWin1[[name]],
test.data$basho,
test.data$day,
test.data$shikona1,
test.data$ordinal1,
test.data$shikona2,
test.data$ordinal2,
USE.NAMES = FALSE
)
}
}
analyse("simple")
aproach("simple")
approach("simple")
analyse("simple")
length(approach("random"))
analyse("random")
head(test.data)
length(approach("simple"))
approach("simple")
?mapply
unlist(approach("simple"))
length(unlist(approach("simple")))
ordinal1 <- 1
ordinal2 <- 100
train.data.summary[which(train.data.summary$below == ordinal1 - ordinal2), ]$winRate
length(train.data.summary[which(train.data.summary$below == ordinal1 - ordinal2), ]$winRate)
ordinal2 <- 2
train.data.summary[which(train.data.summary$below == ordinal1 - ordinal2), ]$winRate
length(train.data.summary[which(train.data.summary$below == ordinal1 - ordinal2), ]$winRate)
pWin1 <- list(
# baseline: random pick from a beta distribution
random = function(basho, day, shikona1, ordinal1, shikona2, ordinal2) rbeta(1, 1, 1),
# simplistic approach: historical win rate for given difference in rank
#   61.2% with one year's worth of historical data
#   60,2% with three years?!
simple = function(basho, day, shikona1, ordinal1, shikona2, ordinal2) {
x <- train.data.summary[which(train.data.summary$below == ordinal1 - ordinal2), ]$winRate
ifelse(length(x) == 1, x, 0.5)
}
)
analyse("random")
analyse("simple")
addFeatures <- function(df) {
df %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = as.factor(substr(rank1, 1, 1)),
level2 = as.factor(substr(rank2, 1, 1))
)
}
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = addFeatures(train.data),
importance = TRUE
)
model
prob = predict(model, addFeatures(test.data), type = "prob")
str(train.data)
str(addFeatures(train.data))
str(addFeatures(test.data))
prob = predict(model, addFeatures(test.data), type = "prob")
head(addFeatures(test.data)[, c("ordinal1", "ordinal2", "below", "level1", "level2")])
prob = predict(model, addFeatures(test.data)[, c("ordinal1", "ordinal2", "below", "level1", "level2")], type = "prob")
?predict
prob = predict(model, newdata = addFeatures(test.data)[, c("ordinal1", "ordinal2", "below", "level1", "level2")], type = "prob")
model
prob = predict(model, addFeatures(test.data), type = "prob")
str(addFeatures(train.data))
str(addFeatures(test.data))
?as.factor
addFeatures <- function(df) {
df %>% mutate(
win1 = as.factor(win1),
win2 = as.factor(win2),
below = ordinal1 - ordinal2,
level1 = as.ordered(substr(rank1, 1, 1)),
level2 = as.ordered(substr(rank2, 1, 1))
)
}
model <- randomForest(
formula = win1 ~ ordinal1 + ordinal2 + below + level1 + level2,
data = addFeatures(train.data),
importance = TRUE
)
model
str(addFeatures(train.data))
prob = predict(model, addFeatures(test.data), type = "prob")
str(prob)
head(prob)
head(prob[, 2])
graphics.off()
pred <- prediction(
predictions = prob[, 2], #approach(name),
labels = test.data$win1
)
head(pred)
pred
windows()
plot(
performance(pred, measure = "tpr", x.measure = "fpr"),
colorize = TRUE,
main = sprintf("AUC = %.1f%%", unlist(performance(pred, "auc")@y.values) * 100)
)
lines(x = c(0, 1), y = c(0, 1))
windows()
acc = performance(pred, "acc")
ac.val = max(unlist(acc@y.values))
th = unlist(acc@x.values)[unlist(acc@y.values) == ac.val]
plot(
acc,
main = paste("Cutoff:", paste(sprintf("%.1f%%", th[order(th)] * 100), collapse = ", ")),
xlab = ""
)
abline(v = th, col = "grey", lty = 2)
